phi.f.inv.i.mod <- function(q, i, n, s){
ep = 10^(-18)
if(i!=n){
if(q>0){
if (s!=1&&s!=0){
f <- function(x)(1-(i/n)^s*x^(1-s)-(1-i/n)^(s)*(1-x)^(1-s))*2*n/(s-s^2) - q^2
if (f(ep)<0){
CC=0
}else{
CC=stats::uniroot(f,c(ep,i/n),tol=1e-100)$root
}
}else if (s==1){
f <- function(x)2*n*((i/n)*log(i/n/x)+(1-i/n)*log((1-i/n)/(1-x)))-q^2
if (f(ep)<0){
CC=0
}else{
CC=stats::uniroot(f,c(ep,i/n),tol=1e-100)$root
}
}else{
f <- function(x)2*n*((x)*log(x/(i/n))+(1-x)*log((1-x)/(1-i/n)))-q^2
if (f(ep)<0){
CC=0
}
else{
CC=stats::uniroot(f,c(ep,i/n),tol=1e-100)$root
}
}
}else if(q<0){
if (s!=1&&s!=0){
f <- function(x)(1-(i/n)^s*x^(1-s)-(1-i/n)^(s)*(1-x)^(1-s))*2*n/(s-s^2) - q^2
if (f(1-ep)<0){
CC=1
}else{
CC=stats::uniroot(f,c(i/n, 1-ep),tol=1e-100)$root
}
}else if (s==1){
f <- function(x)2*n*((i/n)*log(i/n/x)+(1-i/n)*log((1-i/n)/(1-x)))-q^2
if (f(1-ep)<0){
CC=1
}else{
CC=stats::uniroot(f,c(i/n, 1-ep),tol=1e-100)$root
}
}else{
f <- function(x)2*n*((x)*log(x/(i/n))+(1-x)*log((1-x)/(1-i/n)))-q^2
if (f(1-ep)<0){
CC=1
}else{
CC=stats::uniroot(f,c(i/n, 1-ep),tol=1e-100)$root
}
}
}else{
CC = i/n
}
}else{
if(q<=0||s<=0){
CC = 1
}else{
if(s==1){
f <- function(x)-2*log(x)*n - q^2
CC=stats::uniroot(f,c(ep,1),tol=1e-100)$root
}else{
f <- function(x)(1-x^(1-s))*2*n/(s-s^2) - q^2
CC=stats::uniroot(f,c(ep,1),tol=1e-100)$root
}
}
}
return(CC)
}
pphi.rho.mod <- function(threshold, n, rho, k0, k1, NODES=seq(-4,4,length.out=40),
s=2, t=30, MHC=FALSE){
if (t > (k1-k0+1)) {t=k1-k0+1}
u = sapply(1:k1,function(x)phi.f.inv.i.mod(threshold, x, n, s))
um = u[length(u)]
if(rho!=0){
SUM = sum(stats::dnorm(NODES))
result = 0
for(z in NODES){
d = stats::pnorm((stats::qnorm(1-u/2)-sqrt(rho)*z)/sqrt(1-rho),lower.tail = F) +
stats::pnorm((-stats::qnorm(1-u/2)-sqrt(rho)*z)/sqrt(1-rho))
dm = stats::pnorm((stats::qnorm(1-um/2)-sqrt(rho)*z)/sqrt(1-rho),lower.tail = F) +
stats::pnorm((-stats::qnorm(1-um/2)-sqrt(rho)*z)/sqrt(1-rho))
result = result + stats::dnorm(z)*UnifCross_v1.mod(d,dm,t=t,n=n,k0=k0,k1=k1)/SUM
}
return(result)
}else{
if (MHC) return(UnifCross_v1_MHC(u,um,t=t,n=n,k0=k0,k1=k1))
else return(UnifCross_v1.mod(u,um,t=t,n=n,k0=k0,k1=k1)) #for independent studies, only depends on UnifCross_v1 function
}
}
UnifCross_v1.mod <- function(u, um, t, n, k0, k1){
m = floor(k1)
pp = rep(NA, t)
pp[1] = stats::pbeta(um,m,n-m+1,lower.tail=F)
pp[2:t] = (lfactorial(n) - lfactorial(n-(k0:(k0+t-2))))+log(stats::pbeta(um,m-(k0:(k0+t-2)),n-m+1,lower.tail=F))
a = rep(1,t)
a[2] = -stats::dpois(k0,u[k0])*exp(u[k0])
if(t>1){
for (i in 2:(t-1)){
d = stats::dpois(c(1:(i-1), i+k0-1),u[i+k0-1])*exp(u[i+k0-1])
a[i+1]=-a[i:1]%*%d
}
a_pos=which(a[2:t]>0)+1
a_neg=which(a[2:t]<0)+1
p_val=a[1]*pp[1]+sum(exp(pp[a_pos]+log(a[a_pos])))-sum(exp(pp[a_neg]+log(-a[a_neg])))
return(p_val)
}else{
p = stats::pbeta(u[k0], k0, n-k0+1)
return(1-drop(p))
}
}
UnifCross_v1_MHC <- function(u, um, n, t,k0, k1){
alpha=1/n #lower threshold
m = floor(k1)
u=sapply(u,function(x) max(x,alpha))
um=max(um,alpha)
pp = Rmpfr::mpfr(rep(NA, t),80)
pp[1]=Rmpfr::mpfr(sum(stats::pbinom(0:(k0-1),size = n,prob=alpha)*stats::pbeta((um-alpha)/(1-alpha),m:(m-k0+1),n-m+1,lower.tail=F)),80)
pp[2:t] = Rmpfr::mpfr(exp(lfactorial(n) - lfactorial(n-(k0:(k0+t-2))))*stats::pbeta(um,m-(k0:(k0+t-2)),n-m+1,lower.tail=F),80)
a = Rmpfr::mpfr(rep(1,t),80)
a[2] =Rmpfr::mpfr((alpha^k0-stats::pbinom(k0-1,k0,alpha/u[k0])*u[k0]^k0)/factorial(k0),80)
if(t>1){
for (i in 2:(t-1)){
d = Rmpfr::mpfr(c((-stats::dpois(1:(i-1),u[i+k0-1])*exp(u[i+k0-1])),
(alpha^(i+k0-1)-stats::pbinom(k0-1,i+k0-1,alpha/u[i+k0-1])*u[i+k0-1]^(i+k0-1))/factorial(i+k0-1)),80)
a[i+1]=a[i:1]%*%d
}
return(Rmpfr::asNumeric(drop(pp[1:t]%*%a[1:t])))
}else{
p = stats::pbeta(u[k0], k0, n-k0+1)
return(1-drop(p))
}
}
#####Prepare functions for IS#########
HC.stat=function(x, k0=1, k1,thre=FALSE) {
t_mesh = Rfast::rowSort(abs(x),descending = TRUE)
K=dim(t_mesh)[2]
n=dim(t_mesh)[1]
tailprob = 2*stats::pnorm(t_mesh,lower.tail=F)
tailprob=tailprob[,k0:k1]
if (thre) {
tailprob[which(tailprob<1/K)]=k1/K
}
GHC.mesh=(matrix(rep(k0:k1,times=n),nrow = n,byrow = T)-K*tailprob)/sqrt(K*tailprob*(1-tailprob))
GHCstat = Rfast::rowMaxs(GHC.mesh,value = T)
return(stat=GHCstat)
}
CE.HC.mixed.prop=function(K,theta,N1=1000,k0,k1,thre,prop=0.2) {
if (prop==-Inf) {grad=rep(1,K)}
else {grad=c(rep(0,ceiling(K^(prop))),rep(1,floor(K-K^(prop))))}
mix.prop=matrix(stats::rbinom(K*N1,size=1,prob=grad),nrow=K)
mix.prop=Rfast::transpose(mix.prop)
x=matrix(Rfast::Rnorm(K*N1,0,theta),nrow = N1)^{(mix.prop)}+matrix(Rfast::Rnorm(K*N1),nrow = N1)^{1-(mix.prop)}-1
stat.val=HC.stat(x=x,k0=k0,k1=k1,thre=thre)
log_g_norm <- Rfast::rowsums(log(stats::dnorm(x))) # numerator part
log_g_mix <- Rfast::rowsums(log(Rfast::transpose(Rfast::transpose(stats::dnorm(x,0,theta))*grad)+Rfast::transpose(Rfast::transpose(stats::dnorm(x))*(1-grad))))
w=exp(log_g_norm-log_g_mix)
#s=rowsums(x[,grad==1]^2)
return(list(stat.val=stat.val,weight=w,x=x))
}
mixed.par.update.prop=function(object,ro,K,prop) {
stat.val=object[[1]]
gamma=stats::quantile(stat.val,1-ro)
weight=object[[2]]
x.mat=Rfast::transpose(object[[3]])
B=length(stat.val)
if (prop==-Inf) {grad=rep(1,K)}
else {grad=c(rep(0,ceiling(K^(prop))),rep(1,floor(K-K^(prop))))}
opt=stats::optimize(function(t) 1/B*sum(weight[stat.val>=gamma]*apply(x.mat[,stat.val>=gamma],2,function(x) sum(log(grad*stats::dnorm(x,0,t)+(1-grad)*stats::dnorm(x,0,1))))),
interval = c(0,5),maximum = TRUE)
par=opt$maximum
return(list(gamma=gamma,par=par))
}
CE.HC.mixed.grad=function(K,theta,k0=1,k1,N1=1000,idx=1,thre=FALSE) {
grad=1/((1:K)^idx+1)
mix.prop=matrix(stats::rbinom(K*N1,size=1,prob=grad),nrow=K)
mix.prop=Rfast::transpose(mix.prop)
x=matrix(Rfast::Rnorm(K*N1,0,theta),nrow = N1)^{(mix.prop)}+matrix(Rfast::Rnorm(K*N1),nrow = N1)^{1-(mix.prop)}-1
stat.val=HC.stat(x=x,k0=k0, k1=k1,thre=thre)
log_g_norm <- Rfast::rowsums(log(stats::dnorm(x))) # numerator part
log_g_mix <- Rfast::rowsums(log(Rfast::transpose(Rfast::transpose(stats::dnorm(x,0,theta))*grad)+Rfast::transpose(Rfast::transpose(stats::dnorm(x))*(1-grad))))
w=exp(log_g_norm-log_g_mix)
return(list(stat.val=stat.val,weight=w,x=x))
}
mixed.par.update.grad=function(object,ro,K,idx=1) {
stat.val=object[[1]]
gamma=stats::quantile(stat.val,1-ro)
weight=object[[2]]
x.mat=Rfast::transpose(object[[3]])
B=length(stat.val)
grad=1/((1:K)^idx+1)
opt=stats::optimize(function(t) 1/B*sum(weight[stat.val>=gamma]*apply(x.mat[,stat.val>=gamma],2,function(x) sum(log(grad*stats::dnorm(x,0,t)+(1-grad)*stats::dnorm(x,0,1))))),
interval = c(0,5),maximum = TRUE)
#opt=optim(2,function(t) 1/B*sum(weight[stat.val>=gamma]*apply(x.mat[,stat.val>=gamma],2,function(x) sum(log(grad*dnorm(x,0,t)+(1-grad)*dnorm(x,0,1)))),method="L-BFGS-B"),
# control=list(fnscale=-1))
par=opt$maximum
#par=opt$par
return(list(gamma=gamma,par=par))
}
########Prepare funs of Li-Siegmund##########
Cx_HC=function(x,eps) {
C=(2*x+eps^2-eps*sqrt(eps^2+4*(1-x)*x))/(2*(1+eps^2))
deltaC=1/(1+eps^2)-eps*(1-2*x)/((1+eps^2)*sqrt(eps^2+4*(1-x)*x))
return(list(C=C, deltaC=deltaC))
}
########Prepare funs of BL##########
PM_updateindep <-
function(ind,t_mesh,cv,PM,tailprob){
denom=sum(PM[1:(cv[ind-1]+1),ind-1])
for(a_k in 0:cv[ind]){
for(a_k1 in 0:cv[ind-1]){
PM[a_k+1,ind] = PM[a_k+1,ind] + stats::dbinom(a_k,a_k1,tailprob[ind]/tailprob[ind-1])*PM[a_k1+1,ind-1]
}
}
PM[1:(cv[ind]+1),ind] = PM[1:(cv[ind]+1),ind]/denom
return(PM)
}
#######Naive Monte Carlo###############
MC.est=function(K,N1=10^4,B=10^3,k0=1,k1=NA,thre,q) {
k0=floor(k0)
if(is.na(k1)){
k1 = K
}else{
k1 = floor(k1)
}
stat.vals=lapply(1:B,function(b) {
x=matrix(stats::rnorm(K*N1,0,1),nrow = N1)
stat.val=HC.stat(x=x,k0=k0,k1=k1,thre=thre)
return(stat.val)
})
stat.vals=unlist(stat.vals)
p=mean(stat.vals>=q)
return(p)
}
mst <- function(q, K, k0=1, k1=NA, thre=FALSE){
k0=floor(k0)
if(is.na(k1)){
k1 = K
}else{
k1 = floor(k1)
}
return(1-pphi.mod(q=q,K=K, k0=k0, k1=k1, s=2, MHC = thre))
}
pset=runif(2001)
hcstat <-HCstat(pset,k0=1,k1=NA, thre=FALSE)
hcstat
HCstat <- function (pset, k0=1, k1=NA,thre=F) {
K=length(pset)
pset=sort(pset,decreasing = F)
if(is.na(k1)){
k1 = K
}else{
k1 = floor(k1)
}
tailprob=pset[k0:k1]
if (thre) {
tailprob[which(tailprob<1/K)]=k1/K
}
GHC.mesh=(k0:k1 - K*tailprob)/sqrt(K*tailprob*(1-tailprob))
return(stat=max(GHC.mesh,na.rm=TRUE))
}
hcstat <-HCstat(pset,k0=1,k1=NA, thre=FALSE)
hcstat
mst(q=hcstat, K=2001, k0=1, k1=2001, thre=FALSE)
mst <- function(q, K, k0=1, k1=NA, t=500,thre=FALSE){
k0=floor(k0)
if(is.na(k1)){
k1 = K
}else{
k1 = floor(k1)
}
return(1-pphi.mod(q=q,K=K, k0=k0, k1=k1, s=2,t=t, MHC = thre))
}
mst(q=hcstat, K=2001, k0=1, k1=2001, thre=FALSE)
mst <- function(q, K, k0=1, k1=NA, t=100,thre=FALSE){
k0=floor(k0)
if(is.na(k1)){
k1 = K
}else{
k1 = floor(k1)
}
return(1-pphi.mod(q=q,K=K, k0=k0, k1=k1, s=2,t=t, MHC = thre))
}
mst(q=hcstat, K=2001, k0=1, k1=2001, thre=FALSE)
mst <- function(q, K, k0=1, k1=NA, t=50,thre=FALSE){
k0=floor(k0)
if(is.na(k1)){
k1 = K
}else{
k1 = floor(k1)
}
return(1-pphi.mod(q=q,K=K, k0=k0, k1=k1, s=2,t=t, MHC = thre))
}
mst(q=hcstat, K=2001, k0=1, k1=2001, thre=FALSE)
mst <- function(q, K, k0=1, k1=NA, t=30,thre=FALSE){
k0=floor(k0)
if(is.na(k1)){
k1 = K
}else{
k1 = floor(k1)
}
return(1-pphi.mod(q=q,K=K, k0=k0, k1=k1, s=2,t=t, MHC = thre))
}
mst(q=hcstat, K=2001, k0=1, k1=2001, thre=FALSE)
mst(q=1000, K=2001, k0=1, k1=2001, thre=FALSE)
mst(q=1000, K=2001, k0=1, k1=2001, t=2001,thre=FALSE)
hcstat <-HCstat(pset,k0=1,k1=NA, thre=T)
pset=runif(100)
mhcstat <-HCstat(pset,k0=1,k1=NA, thre=T)
mhcstat
mst(q=mhcstat, K=100, k0=1, k1=100, t=100,thre=T)
mst(q=mhcstat, K=100, k0=1, k1=100, t=30,thre=T)
mst(q=hcstat, K=2001, k0=1, k1=2001, t=30,thre=T)
pset=runif(1000)
hcstat
mst(q=hcstat, K=200, k0=1, k1=200, t=30,thre=F)
ufi.p(K=200,q=hcstat)
ufi.p(K=2000,q=hcstat)
mst(q=hcstat, K=2000, k0=1, k1=2000, t=30,thre=F)
library(devtools)
install_github("wenjiaking/HCp@master")
library(HCp)
rm(list=ls())
library(HCp)
pset=runif(10)
HCstat(pset,k0=1,k1=10,thre=F)
hcstat <-HCstat(pset,k0=1,k1=10,thre=F)
XH(q=hcstat,K=10)
mhcstat <-HCstat(pset,k0=1,k1=10,thre=T)
mhcstat
LiAppro_HC(q=mhcstat,K=10)
mst(q=hcstat,K=10,k0=1,k1=10,thre=F)
mst(q=mhcstat,K=10,k0=1,k1=10,thre=T)
CE.mixed.grad(q=hcstat,K=10,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=10,thre=F,idx=1,theta=1)
CE.mixed.prop(q=mhcstat,K=10,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=10,thre=T,prop=0.2,theta=1)
q=sapply(10:15,function(i) {
pset=runif(i)
return(HCstat(pset,k0=1,thre=FALSE))
})
ufi.p(flibs=HC_flibs,K=10:15,q=q)
q
ufi.q(flibs_q=HC_flibs_q,K=10:15,p=10^(seq(-3,-8)))
pset=runif(200)
HCstat(pset,k0=1,k1=200, thre=FALSE)
hybrid(q=HCstat(pset,k0=1,k1=80, thre=FALSE), K=200, k0=1,k1=80, thre=FALSE,N=10^6)
pset=runif(2001)
hybridSpec(q=HCstat(pset,k0=1,k1=2001, thre=FALSE), K=2001, flibs=HC_flibs,N=10^6)
library(HCp)
pset=runif(1000)
HCstat(pset,k0=1,k1=1000,thre=F)
pset=runif(10)
hcstat <-HCstat(pset,k0=1,k1=10,thre=F)
XH(q=hcstat,K=10)
mhcstat <-HCstat(pset,k0=1,k1=10,thre=T)
mhcstat #8.100423
LiAppro_HC(q=mhcstat,K=10)
mhcstat
mst(q=hcstat,K=10,k0=1,k1=10,thre=F)
hcstat
mst(q=mhcstat,K=10,k0=1,k1=10,thre=T)
CE.mixed.grad(q=hcstat,K=10,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=10,thre=F,idx=1,theta=1)
CE.mixed.prop(q=mhcstat,K=10,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=10,thre=T,prop=0.2,theta=1)
q=sapply(10:15,function(i) {
pset=runif(i)
return(HCstat(pset,k0=1,thre=FALSE))
})
ufi.p(flibs=HC_flibs,K=10:15,q=q)
q
ufi.q(flibs_q=HC_flibs_q,K=10:15,p=10^(seq(-3,-8)))
pset=runif(200)
hybrid(q=HCstat(pset,k0=1,k1=80, thre=FALSE), K=200, k0=1,k1=80, thre=FALSE,N=10^6)
pset=runif(2001)
HCstat(pset,k0=1,k1=2001, thre=FALSE)
HCstat(pset,k0=1,k1=2001, thre=FALSE)
hybridSpec(q=HCstat(pset,k0=1,k1=2001, thre=FALSE), K=2001, flibs=HC_flibs,N=10^6)
# some random test #
pset=rep(0,1000)
HCstat(pset,k0=1,k1=1000,thre=F)
hcstat <-HCstat(pset,k0=1,k1=1000,thre=F)
XH(q=hcstat,K=1000)
hcstat <-HCstat(pset,k0=1,k1=1000,thre=T)
LiAppro_HC(q=hcstat,K=1000)
pset=rep(1,1000)
hcstat <-HCstat(pset,k0=1,k1=1000,thre=F)
XH(q=hcstat,K=1000)
hcstat <-HCstat(pset,k0=1,k1=1000,thre=T)
LiAppro_HC(q=hcstat,K=1000)
pset=runif(1000)
hcstat <-HCstat(pset,k0=1,k1=1000,thre=F)
pset=runif(100000)
hcstat <-HCstat(pset,k0=1,k1=10^5,thre=T)
hcstat
LiAppro_HC(q=hcstat,K=length(pset))
LiAppro_HC(q=hcstat,K=length(pset),thre=T)
pset=runif(3000)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
hcstat
pset=rbeta(3000,1,3)
summary(pset)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
hcstat
LiAppro_HC(q=hcstat,K=length(pset))
pset=rbeta(3000,1,2)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
hcstat
LiAppro_HC(q=hcstat,K=length(pset))
pset=rbeta(300,1,2)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
hcstat
LiAppro_HC(q=hcstat,K=length(pset))
pset=runif(30)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
hcstat
LiAppro_HC(q=hcstat,K=length(pset)) #7.407695e-05
set.seed(7)
res=c()
hc=c() #also check the HC values
for(i in 1:1000){
pset=runif(10)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
hc[i]=hcstat
res[i]=LiAppro_HC(q=hcstat,K=length(pset))
}
summary(hc)
summary(res)
set.seed(7)
res1=res2=c()
pset=runif(1000)
for(i in 1:1000){
print(i)
mhcstat <-HCstat(pset,k0=1,k1=1000,thre=T)
hcstat <-HCstat(pset,k0=1,k1=1000,thre=F)
res1[i]=mst(q=hcstat,K=1000,k0=1,k1=1000,thre=F)
#res2[i]=mst(q=mhcstat,K=1000,k0=1,k1=1000,thre=T)
}
for(i in 1:1000){
pset=runif(1000)
#mhcstat <-HCstat(pset,k0=1,k1=1000,thre=T)
hcstat <-HCstat(pset,k0=1,k1=1000,thre=F)
res1[i]=mst(q=hcstat,K=1000,k0=1,k1=1000,thre=F)
#res2[i]=mst(q=mhcstat,K=1000,k0=1,k1=1000,thre=T)
}
pset=runif(10)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=F)
XH(q=hcstat,K=10)
hcstat
pset=runif(50)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=F)
XH(q=hcstat,K=50)
pset=runif(50)
mhcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
mst(q=hcstat,K=10,k0=1,k1=50,thre=F)
mst(q=mhcstat,K=10,k0=1,k1=50,thre=T)
pset=runif(50)
mhcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
mst(q=hcstat,K=50,k0=1,k1=50,thre=F)
mst(q=mhcstat,K=50,k0=1,k1=50,thre=T)
pset=runif(50)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=F)
mhcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
CE.mixed.grad(q=hcstat,K=50,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=50,thre=F,idx=1,theta=1)
CE.mixed.prop(q=mhcstat,K=50,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=50,thre=T,prop=0.2,theta=1)
pset=runif(50)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=F)
mhcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
CE.mixed.grad(q=hcstat,K=50,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=50,thre=F,idx=1,theta=1)
CE.mixed.prop(q=mhcstat,K=50,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=50,thre=T,prop=0.3,theta=1)
mhcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
mhcstat
mst(q=mhcstat,K=50,k0=1,k1=50,thre=T)
CE.mixed.grad(q=hcstat,K=50,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=50,thre=F,idx=1,theta=1)
pset=runif(50)
hcstat <-HCstat(pset,k0=1,k1=length(pset),thre=F)
XH(q=hcstat,K=50)
mhcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
mst(q=hcstat,K=50,k0=1,k1=50,thre=F)
mst(q=mhcstat,K=50,k0=1,k1=50,thre=T)
```
CE.mixed.grad(q=hcstat,K=50,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=50,thre=F,idx=1,theta=1)
CE.mixed.prop(q=mhcstat,K=50,ro=0.01,N0=10^4, N1=10^4,B=1,k0=1,k1=50,thre=T,prop=0.2,theta=1)
pset=rbeta(100,1,2) #only reliable for small p-value computing
mhcstat <-HCstat(pset,k0=1,k1=length(pset),thre=T)
LiAppro_HC(q=mhcstat,K=length(pset))
mhcstat
mst(q=mhcstat,K=length(pset),k0=1,k1=length(pset),thre=T)
q=sapply(10:15,function(i) {
pset=runif(i)
return(HCstat(pset,k0=1,thre=FALSE))
})
ufi.p(flibs=HC_flibs,K=10:15,q=q)
ufi.q(flibs_q=HC_flibs_q,K=10:15,p=10^(seq(-3,-8)))
XH(q=q[1],K=10)
XH(q=q[2],K=11)
XH(q=q[5],K=15)
XH(q=q[6],K=15)
XH(q=q[5],K=14)
pset=runif(200)
hybrid(q=HCstat(pset,k0=1,k1=80, thre=FALSE), K=200, k0=1,k1=80, thre=FALSE,N=10^6)
pset=runif(2001)
hybridSpec(q=HCstat(pset,k0=1,k1=2001, thre=FALSE), K=2001, flibs=HC_flibs,N=10^6)
library(HCp)
pset=runif(2010)
q=HCstat(pset,k0=1,thre=FALSE)
q
ufi.p(flibs=HC_flibs,K=2010,q=q)
hybridSpec(q=q,K=2010,flibs=HC_flibs,N=10^6)
setwd("~/OneDrive - University of Pittsburgh/Combine_p-value/HCp")
library(devtools)
library(roxygen2)
document()
load_all()
check()
build()
